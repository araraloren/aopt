use std::ops::DerefMut;

use proc_macro2::Ident;
use proc_macro2::TokenStream;
use proc_macro_error::abort;
use quote::quote;
use quote::ToTokens;
use syn::punctuated::Punctuated;
use syn::spanned::Spanned;
use syn::Attribute;
use syn::Data::Struct;
use syn::DataStruct;
use syn::DeriveInput;
use syn::Field;
use syn::Fields;
use syn::GenericArgument;
use syn::GenericParam;
use syn::Generics;
use syn::Lifetime;
use syn::Lit;
use syn::PathArguments;
use syn::Token;
use syn::Type;
use syn::TypePath;
use syn::TypeReference;
use syn::WherePredicate;

use crate::global::ArgCfg;
use crate::global::CfgKind;
use crate::global::Configurations;
use crate::global::FieldCfg;
use crate::global::GlobalCfg;
use crate::global::SubCfg;

const HELP_OPTION_Q: &str = "-?";
const HELP_OPTION_SHORT: &str = "-h";
const HELP_OPTION_NAME: &str = "--help";
const HELP_OPTION_HELP: &str = "Display help message";
const HELP_OPTION_WIDTH: usize = 40;
const HELP_USAGE_WIDTH: usize = 10;

pub fn derive_parser(input: &DeriveInput) -> syn::Result<TokenStream> {
    let analyzer = Analyzer::new(input)?;
    let impl_for_parser = analyzer.generate_simple_parser()?;

    Ok(quote! {
        #impl_for_parser
    })
}

#[derive(Debug)]
pub struct Analyzer<'a> {
    struct_meta: StructMeta<'a>,

    field_metas: Vec<FieldMeta<'a>>,
}

impl<'a> Analyzer<'a> {
    pub fn new(input: &'a DeriveInput) -> syn::Result<Self> {
        match input.data {
            Struct(DataStruct {
                fields: Fields::Named(ref fields),
                ..
            }) => {
                let struct_meta = StructMeta::new(input)?;
                let mut field_metas = vec![];

                for field in fields.named.iter() {
                    field_metas.push(FieldMeta::new(field)?);
                }
                Ok(Self {
                    field_metas,
                    struct_meta,
                })
            }
            _ => {
                abort! {
                    input,
                        "cote only support struct format"
                }
            }
        }
    }

    pub fn generate_simple_parser(&self) -> syn::Result<TokenStream> {
        let has_handler_on_field = self.field_metas.iter().any(|v| v.has_handler());
        let has_handler_on_global = self.struct_meta.has_handler();
        let update = self.generate_parser_update()?;
        let extract_value = self.generate_try_extract()?;
        let try_from = self.generate_try_from()?;
        let ident = self.struct_meta.ident;
        let generics = &self.struct_meta.generics.params;
        let where_clause = self.struct_meta.generate_where_clause()?;
        let where_clause = if has_handler_on_field || has_handler_on_global {
            quote! {
                where
                P::Ser: aopt::ser::ServicesValExt + 'zlifetime,
                P::Error: Into<aopt::Error>,
                P::Set: aopt::prelude::Set + aopt::set::SetValueFindExt + 'zlifetime,
                P::Inv<'zlifetime>: aopt::ctx::HandlerCollection<'zlifetime, P::Set, P::Ser>,
                P: aopt::prelude::Policy + aopt::prelude::APolicyExt<P> + Default + 'zlifetime,
                aopt::prelude::SetCfg<P::Set>: aopt::prelude::Config + aopt::prelude::ConfigValue + Default,
                #where_clause
            }
        } else {
            quote! {
                where
                P::Ser: aopt::ser::ServicesValExt + 'zlifetime,
                P::Error: Into<aopt::Error>,
                P::Set: aopt::prelude::Set + aopt::set::SetValueFindExt + 'zlifetime,
                P::Inv<'zlifetime>: aopt::ctx::HandlerCollection<'zlifetime, P::Set, P::Ser>,
                P: aopt::prelude::Policy + aopt::prelude::APolicyExt<P> + Default + 'zlifetime,
                aopt::prelude::SetCfg<P::Set>: aopt::prelude::Config + aopt::prelude::ConfigValue + Default,
                #where_clause
            }
        };
        let parse_interface = self.generate_parse_interface()?;

        if generics.is_empty() {
            Ok(quote! {
                #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                impl<'zlifetime, P> cote::IntoParserDerive<'zlifetime, P> for #ident #where_clause
                {
                    fn update(parser: &mut aopt::prelude::Parser<'zlifetime, P>) -> Result<(), aopt::Error> {
                        #update
                    }
                }

                #extract_value

                #try_from

                #parse_interface
            })
        } else {
            Ok(quote! {
                #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                impl<'zlifetime, #generics, P> cote::IntoParserDerive<'zlifetime, P> for #ident<#generics> #where_clause
                {
                    fn update(parser: &mut aopt::prelude::Parser<'zlifetime, P>) -> Result<(), aopt::Error> {
                        #update
                    }
                }

                #extract_value

                #try_from

                #parse_interface
            })
        }
    }

    pub fn generate_parse_interface(&self) -> syn::Result<TokenStream> {
        let generics = &self.struct_meta.generics.params;
        let ident = self.struct_meta.ident;
        let policy_ty = self.struct_meta.gen_policy_type()?;
        let where_clause = self.struct_meta.generate_where_clause()?;
        let help_handler = self.struct_meta.generate_help_handler(false)?;
        let may_be_display_help = self.struct_meta.generate_help_display(&help_handler)?;
        let style_manager = self.struct_meta.generate_style_manager()?;
        let app_name = &self.struct_meta.application_name;
        let mut other_setting = quote! {};

        for field in self.field_metas.iter() {
            other_setting.extend(field.generate_delay(true)?);
        }
        other_setting.extend(quote! { policy; });
        let inner = quote! {
            #[doc=concat!("Generate a [`Parser`] from [`", stringify!(#ident), "`].")]
            pub fn into_parser<'yliftime>() -> Result<aopt::prelude::Parser<'yliftime, #policy_ty>, aopt::Error> {
                let mut parser = <Self as cote::IntoParserDerive<#policy_ty>>::into_parser()?;
                #style_manager
                {
                    let policy = parser.policy_mut();
                    #other_setting
                }
                Ok(parser)
            }

            /// Parsing the given arguments and return the [`GetoptRes`](aopt::GetoptRes).
            pub fn parse_args<'yliftime>(args: aopt::prelude::Args)
                -> Result<aopt::GetoptRes<<#policy_ty as aopt::prelude::Policy>::Ret, aopt::prelude::Parser<'yliftime, #policy_ty>>, aopt::Error> {
                let mut parser = Self::into_parser()?;
                parser.set_app_data(vec![#app_name])?;
                parser.init()?;
                let ret = parser.parse(aopt::ARef::new(args)).map_err(Into::into);
                // if has failure
                #may_be_display_help
                Ok(aopt::GetoptRes{ ret: ret?, parser })
            }

            /// Parsing arguments returned from [`from_env`](aopt::prelude::Args::from_env) and return the [`GetoptRes`](aopt::GetoptRes).
            pub fn parse_env_args<'yliftime>()
            -> Result<aopt::GetoptRes<<#policy_ty as aopt::prelude::Policy>::Ret, aopt::prelude::Parser<'yliftime, #policy_ty>>, aopt::Error> {
                Self::parse_args(aopt::prelude::Args::from_env())
            }
        };
        let no_ref_inner = quote! {
            /// Parsing the given arguments and generate a .
            pub fn parse(args: aopt::prelude::Args) -> Result<Self, aopt::Error> {
                let GetoptRes { ret, mut parser } = Self::parse_args(args)?;

                if ret.status() {
                    Self::try_extract(parser.optset_mut())
                }
                else {
                    let ctx = ret.ctx();
                    let args = ctx.args();
                    let inner_ctx = ctx.inner_ctx().ok();
                    let e = ret.failure();
                    Err(aopt::Error::raise_error(
                        format!("Parsing arguments `{:?}` failed: {:?}, inner_ctx = {:?}", 
                            args, e.display(), inner_ctx)))
                }
            }

            pub fn parse_env() -> Result<Self, aopt::Error> {
                Self::parse(aopt::prelude::Args::from_env())
            }
        };

        Ok(if self.struct_meta.lifetimes.is_empty() {
            if generics.is_empty() {
                quote! {
                    #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                    impl #ident {
                        #inner

                        #no_ref_inner
                    }
                }
            } else {
                quote! {
                    #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                    impl <#generics> #ident<#generics> where #where_clause {
                        #inner

                        #no_ref_inner
                    }
                }
            }
        } else {
            if generics.is_empty() {
                quote! {
                    #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                    impl #ident {
                        #inner
                    }
                }
            } else {
                quote! {
                    #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                    impl <#generics> #ident<#generics> where #where_clause {
                        #inner
                    }
                }
            }
        })
    }

    pub fn generate_parser_update(&self) -> syn::Result<TokenStream> {
        let mut ret = quote! {
            let set = parser.optset_mut();
            let ctor_name = aopt::prelude::ctor_default_name();
            let ctor = set.ctor_mut(&ctor_name)?;
        };
        let mut configs = vec![];
        let mut inserts = vec![];
        let mut handlers = vec![];
        let insert_help = self
            .struct_meta
            .global_cfg
            .find_cfg(CfgKind::ParserHelp)
            .is_some();
        let abort_help = self
            .struct_meta
            .global_cfg
            .find_cfg(CfgKind::ParserAbortHelp)
            .is_some();

        const HELP_OPTION_IDENT: &str = "help_option";
        const MAIN_OPTION_IDENT: &str = "main_option";
        const MAIN_OPTION_UID: &str = "main_option_uid";

        // insert main if global has `on`
        if let Some(cfg) = self.struct_meta.global_cfg.find_cfg(CfgKind::ParserOn) {
            let value = &cfg.value;
            let ident = Ident::new(MAIN_OPTION_IDENT, self.struct_meta.ident.span());
            let uid_ident = Ident::new(MAIN_OPTION_UID, self.struct_meta.ident.span());

            configs.push(quote! {
                let #ident = {
                    ctor.new_with({
                        let mut config = aopt::prelude::SetCfg::<P::Set>::default();
                        config.set_name(#MAIN_OPTION_IDENT);
                        <aopt::opt::Main>::infer_fill_info(&mut config, true);
                        config
                    }).map_err(Into::into)?
                };
            });
            inserts.push(quote! {
                let #uid_ident = set.insert(#ident);
            });
            handlers.push(quote! {
                parser.entry(#uid_ident)?.on(#value);
            });
        }
        // insert help option
        let help_option_uid = Ident::new(
            &format!("{}_uid", HELP_OPTION_IDENT),
            self.struct_meta.ident.span(),
        );

        if insert_help {
            let ident = Ident::new(HELP_OPTION_IDENT, self.struct_meta.ident.span());

            configs.push(quote! {
                let #ident = {
                    ctor.new_with({
                        let mut config = aopt::prelude::SetCfg::<P::Set>::default();
                        config.set_name(#HELP_OPTION_NAME);
                        config.add_alias(#HELP_OPTION_SHORT);
                        config.add_alias(#HELP_OPTION_Q);
                        config.set_help(#HELP_OPTION_HELP);
                        <bool>::infer_fill_info(&mut config, true);
                        config
                    }).map_err(Into::into)?
                };
            });
            inserts.push(quote! {
                #[allow(unused)]
                let #help_option_uid = set.insert(#ident);
            });
        }
        for (idx, field) in self.field_metas.iter().enumerate() {
            let ident = Ident::new(&format!("option{}", idx), field.ident.span());
            let config = field.generate_config()?;

            configs.push(quote! {
                let #ident = {
                    ctor.new_with({ #config }).map_err(Into::into)?
                };
            });
            if field.has_handler() {
                let uid_ident = Ident::new(&format!("option_uid_{}", idx), field.ident.span());
                let help_handler = self.struct_meta.generate_help_handler(true)?;
                let handler = field.generate_handler(
                    &uid_ident,
                    &help_option_uid,
                    insert_help,
                    abort_help,
                    help_handler,
                )?;

                inserts.push(quote! {
                    let #uid_ident = set.insert(#ident);
                });
                handlers.push(quote! {
                    #handler
                });
            } else {
                inserts.push(quote! {
                    set.insert(#ident);
                });
            }
        }
        ret.extend(configs.into_iter());
        ret.extend(inserts.into_iter());
        ret.extend(handlers.into_iter());
        ret.extend(quote! { Ok(()) });
        Ok(ret)
    }

    pub fn generate_try_from(&self) -> syn::Result<TokenStream> {
        let generics = &self.struct_meta.generics.params;
        let where_clause = self.struct_meta.generate_where_clause_with_zlifetime()?;
        let ident = self.struct_meta.ident;
        let policy_ty = self.struct_meta.gen_policy_type()?;

        Ok(if self.struct_meta.lifetimes.is_empty() {
            if generics.is_empty() {
                quote! {
                    #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                    impl <'zlifetime> std::convert::TryFrom<&'zlifetime mut aopt::prelude::Parser<'_, #policy_ty>> for #ident {
                        type Error = aopt::Error;

                        fn try_from(parser: &'zlifetime mut aopt::prelude::Parser<'_, #policy_ty>) -> Result<Self, Self::Error> {
                            <#ident as cote::ExtractFromSetDerive<aopt::prelude::ASet>>::try_extract(parser.optset_mut())
                        }
                    }
                }
            } else {
                quote! {
                    #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                    impl <'zlifetime, #generics> std::convert::TryFrom<&'zlifetime mut aopt::prelude::Parser<'_, #policy_ty>>
                        for #ident<#generics> where #where_clause {
                        type Error = aopt::Error;

                        fn try_from(parser: &'zlifetime mut aopt::prelude::Parser<'_, #policy_ty>) -> Result<Self, Self::Error> {
                            <#ident as cote::ExtractFromSetDerive<aopt::prelude::ASet>>::try_extract(parser.optset_mut())
                        }
                    }
                }
            }
        } else {
            quote! {}
        })
    }

    pub fn generate_try_extract(&self) -> syn::Result<TokenStream> {
        let mut mut_field = quote! {};
        let mut ref_field = quote! {};
        let generics = &self.struct_meta.generics.params;
        let where_clause = self.struct_meta.generate_where_clause_with_zlifetime()?;
        let ident = self.struct_meta.ident;

        for field in self.field_metas.iter() {
            let (is_reference, code) = if field.is_sub_command() {
                field.generate_command_extract()?
            } else {
                field.generate_option_extract()?
            };

            if is_reference {
                ref_field.extend(code);
            } else {
                mut_field.extend(code);
            }
        }
        Ok(if generics.is_empty() {
            quote! {
                #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                impl <'zlifetime, S> cote::ExtractFromSetDerive<'zlifetime, S>
                    for #ident where S: aopt::prelude::SetValueFindExt, #where_clause {
                    fn try_extract(set: &'zlifetime mut S) -> Result<Self, aopt::Error> where Self: Sized {
                        Ok(Self {
                            #mut_field
                            #ref_field
                        })
                    }
                }
            }
        } else {
            quote! {
                #[doc=concat!("Automatic generated by cote-derive for [`", stringify!(#ident), "`].")]
                impl <'zlifetime, #generics, S> cote::ExtractFromSetDerive<'zlifetime, S>
                    for #ident<#generics> where S: aopt::prelude::SetValueFindExt, #where_clause {
                    fn try_extract(set: &'zlifetime mut S) -> Result<Self, aopt::Error> where Self: Sized {
                        Ok(Self {
                            #mut_field
                            #ref_field
                        })
                    }
                }
            }
        })
    }
}

#[derive(Debug)]
pub struct StructMeta<'a> {
    ident: &'a Ident,

    generics: &'a Generics,

    #[allow(unused)]
    tys: Vec<&'a Ident>,

    lifetimes: Vec<&'a Ident>,

    where_clause: Option<&'a Punctuated<WherePredicate, Token!(,)>>,

    global_cfg: Configurations<GlobalCfg>,

    policy_ty: TokenStream,

    application_name: TokenStream,
}

impl<'a> StructMeta<'a> {
    pub fn new(input: &'a DeriveInput) -> syn::Result<Self> {
        let ident = &input.ident;
        let generics = &input.generics;
        let params = &generics.params;
        let where_clause = generics.where_clause.as_ref().map(|v| &v.predicates);
        let mut lifetimes = vec![];
        let mut tys = vec![];
        let global_cfg = Configurations::<GlobalCfg>::parse_attrs(&input.attrs, "cote");
        let policy = global_cfg.find_cfg(CfgKind::ParserPolicy);
        let policy_name = policy
            .map(|v| v.value.to_token_stream().to_string())
            .unwrap_or(String::from("fwd"));
        let policy_ty = match policy_name.as_str() {
            "pre" => {
                quote! {
                    aopt::prelude::APrePolicy
                }
            }
            "fwd" => {
                quote! {
                    aopt::prelude::AFwdPolicy
                }
            }
            "delay" => {
                quote! {
                    aopt::prelude::ADelayPolicy
                }
            }
            _ => policy.unwrap().value.to_token_stream(),
        };
        let application_name = if let Some(head_cfg) = global_cfg.find_cfg(CfgKind::ParserName) {
            let value = &head_cfg.value;

            quote! {
                String::from(#value)
            }
        } else {
            quote! {
                format!("{}", env!("CARGO_PKG_NAME"))
            }
        };

        for param in params {
            match param {
                GenericParam::Type(ty) => {
                    tys.push(&ty.ident);
                }
                GenericParam::Lifetime(lifetime) => {
                    lifetimes.push(&lifetime.lifetime.ident);
                }
                GenericParam::Const(const_param) => {
                    abort! {
                        input,
                        "analyzer struct failed: Cote not support const parameter `{:?}`",
                        const_param,
                    }
                }
            }
        }
        Ok(Self {
            tys,
            ident,
            generics,
            lifetimes,
            global_cfg,
            policy_ty,
            where_clause,
            application_name,
        })
    }

    pub fn generate_style_manager(&self) -> syn::Result<TokenStream> {
        let mut ret = quote! {};

        if self.global_cfg.find_cfg(CfgKind::ParserCombined).is_some() {
            ret.extend(quote! {
                parser.enable_combined();
            })
        }
        if self
            .global_cfg
            .find_cfg(CfgKind::ParserEmbeddedPlus)
            .is_some()
        {
            ret.extend(quote! {
                parser.enable_embedded_plus();
            })
        }
        Ok(ret)
    }

    pub fn generate_help_display(&self, help_handler: &TokenStream) -> syn::Result<TokenStream> {
        if self.global_cfg.find_cfg(CfgKind::ParserHelp).is_some()
            && self.global_cfg.find_cfg(CfgKind::ParserAbortHelp).is_some()
        {
            Ok(quote! {
                let has_help_set = parser.find_val::<bool>(#HELP_OPTION_NAME).unwrap_or(&false) == &true;
                if ret.is_err() || !ret.as_ref().unwrap().status() || has_help_set  {
                    #help_handler
                    if has_help_set {
                        std::process::exit(0)
                    }
                }
            })
        } else if self.global_cfg.find_cfg(CfgKind::ParserHelp).is_some() {
            Ok(quote! {
                if parser.find_val::<bool>(#HELP_OPTION_NAME).unwrap_or(&false) == &true  {
                    #help_handler
                    std::process::exit(0)
                }
            })
        } else if self.global_cfg.find_cfg(CfgKind::ParserAbortHelp).is_some() {
            Ok(quote! {
                if ret.is_err() || !ret.as_ref().unwrap().status() {
                    #help_handler
                }
            })
        } else {
            Ok(quote! {})
        }
    }

    pub fn  generate_help_handler(&self, for_field: bool) -> syn::Result<TokenStream> {
        let head = if let Some(head_cfg) = self.global_cfg.find_cfg(CfgKind::ParserHead) {
            let value = &head_cfg.value;

            quote! {
                String::from(#value)
            }
        } else {
            quote! {
                format!("{}", env!("CARGO_PKG_DESCRIPTION"))
            }
        };
        let foot = if let Some(head_cfg) = self.global_cfg.find_cfg(CfgKind::ParserFoot) {
            let value = &head_cfg.value;

            quote! {
                String::from(#value)
            }
        } else {
            quote! {
                format!("Create by {} v{}", env!("CARGO_PKG_AUTHORS"), env!("CARGO_PKG_VERSION"))
            }
        };
        let width = if let Some(head_cfg) = self.global_cfg.find_cfg(CfgKind::ParserHelpWidth) {
            let value = &head_cfg.value;

            quote! {
                #value
            }
        } else {
            quote! { #HELP_OPTION_WIDTH }
        };
        let usage_width =
            if let Some(head_cfg) = self.global_cfg.find_cfg(CfgKind::ParserUsageWidth) {
                let value = &head_cfg.value;

                quote! {
                    #value
                }
            } else {
                quote! { #HELP_USAGE_WIDTH }
            };
        let name = if !for_field {
            self.application_name.clone()
        }
        else {
            quote! {
                ser_names.join(" ")
            }
        };

        if self.global_cfg.find_cfg(CfgKind::ParserAbortHelp).is_some()
            || self.global_cfg.find_cfg(CfgKind::ParserHelp).is_some()
        {
            Ok(quote! {
                cote::simple_display_set_help(parser.optset(), #name, #head, #foot, #width, #usage_width)
                            .map_err(|e| aopt::Error::raise_error(format!("Can not display help message: {:?}", e)))?;
            })
        } else {
            Ok(quote! {})
        }
    }

    pub fn has_handler(&self) -> bool {
        self.global_cfg.find_cfg(CfgKind::ParserOn).is_some()
            || self.global_cfg.find_cfg(CfgKind::ParserHelp).is_some()
    }

    pub fn generate_where_clause_with_zlifetime(&self) -> syn::Result<TokenStream> {
        let mut code = quote! {};
        let zlifetime = Lifetime::new("'zlifetime", self.ident.span());

        for lifetime in self.lifetimes.iter() {
            let lifetime = Lifetime::new(&format!("'{}", lifetime), lifetime.span());

            code.extend(quote! {
                #zlifetime: #lifetime,
            });
        }
        Ok(if let Some(where_clause) = self.where_clause {
            quote! { #code #where_clause }
        } else if !self.lifetimes.is_empty() {
            quote! { #code }
        } else {
            quote! {}
        })
    }

    pub fn generate_where_clause(&self) -> syn::Result<TokenStream> {
        Ok(if let Some(where_clause) = self.where_clause {
            quote! { #where_clause }
        } else {
            quote! {}
        })
    }

    pub fn gen_policy_type(&self) -> syn::Result<&TokenStream> {
        Ok(&self.policy_ty)
    }
}

#[derive(Debug)]
pub struct FieldMeta<'a> {
    ident: Option<&'a Ident>,

    ty: &'a Type,

    trimed_ty: Type,

    unwrap_ty: Option<Type>,

    name: TokenStream,

    is_reference: bool,

    is_sub_command: bool,

    #[allow(unused)]
    is_position: bool,

    policy_ty: Option<TokenStream>,

    comment_doc: Vec<Lit>,

    field_cfg: Configurations<FieldCfg>,
}

impl<'a> FieldMeta<'a> {
    pub fn new(field: &'a Field) -> syn::Result<Self> {
        let ident = field.ident.as_ref();
        let ty = &field.ty;
        let (is_reference, trimed_ty) = remove_lifetime(ty);
        let mut unwrap_ty = None;
        let arg_cfg = Configurations::<ArgCfg>::parse_attrs(&field.attrs, "arg");
        let sub_cfg = Configurations::<SubCfg>::parse_attrs(&field.attrs, "sub");
        let comment_doc = filter_comment_doc(&field.attrs);
        let is_sub_command;
        let is_position = check_in_path(ty, "Pos") || check_in_path(ty, "Cmd");
        let mut policy_ty = None;
        let field_cfg: Configurations<FieldCfg> =
            if !arg_cfg.cfgs.is_empty() && !sub_cfg.cfgs.is_empty() {
                abort! {
                    ident,
                    "can not have both `arg` and `sub` on one field",
                }
            } else if !arg_cfg.cfgs.is_empty() {
                is_sub_command = false;
                Configurations {
                    cfgs: arg_cfg.cfgs.into_iter().map(|v| v.into()).collect(),
                }
            } else if !sub_cfg.cfgs.is_empty() {
                let policy = sub_cfg.find_cfg(CfgKind::SubPolicy);
                let policy_name = policy
                    .map(|v| v.value.to_token_stream().to_string())
                    .unwrap_or(String::from("fwd"));

                policy_ty = Some(match policy_name.as_str() {
                    "pre" => {
                        quote! {
                            aopt::prelude::APrePolicy
                        }
                    }
                    "fwd" => {
                        quote! {
                            aopt::prelude::AFwdPolicy
                        }
                    }
                    "delay" => {
                        quote! {
                            aopt::prelude::ADelayPolicy
                        }
                    }
                    _ => policy.unwrap().value.to_token_stream(),
                });
                unwrap_ty = Some(remove_option(&trimed_ty)?);

                is_sub_command = true;
                Configurations {
                    cfgs: sub_cfg.cfgs.into_iter().map(|v| v.into()).collect(),
                }
            } else {
                is_sub_command = false;
                Configurations { cfgs: vec![] }
            };
        let name = if let Some(cfg) = field_cfg.find_cfg(CfgKind::SubName) {
            let value = &cfg.value;
            quote! { #value }
        } else if let Some(cfg) = field_cfg.find_cfg(CfgKind::OptName) {
            let value = &cfg.value;
            quote! { #value }
        } else {
            let ident = ident
                .unwrap_or_else(|| {
                    abort! {
                        ident,
                        "missing filed name",
                    }
                })
                .to_string();
            let name = if is_position || is_sub_command {
                ident
            } else if ident.chars().count() >= 2 {
                format!("--{}", ident)
            } else {
                format!("-{}", ident)
            };

            quote! { #name }
        };

        Ok(Self {
            ident,
            ty,
            trimed_ty,
            name,
            field_cfg,
            policy_ty,
            unwrap_ty,
            comment_doc,
            is_reference,
            is_position,
            is_sub_command,
        })
    }

    pub fn generate_delay(&self, is_delay_policy: bool) -> syn::Result<TokenStream> {
        if is_delay_policy {
            if self.field_cfg.find_cfg(CfgKind::OptNoDelay).is_some() {
                let name = &self.name;

                Ok(quote! {
                    policy.set_no_delay(#name);
                })
            } else {
                Ok(quote! {})
            }
        } else {
            abort! {
                self.ident,
                "option not support `!delay` attribute for current policy type"
            }
        }
    }

    pub fn generate_handler(
        &self,
        ident: &Ident,
        help_uid: &Ident,
        insert_help: bool,
        abort_help: bool,
        help_handler: TokenStream,
    ) -> syn::Result<TokenStream> {
        if let Some(cfg) = self.field_cfg.find_cfg(CfgKind::OptOn) {
            let value = &cfg.value;

            if let Some(then_cfg) = self.field_cfg.find_cfg(CfgKind::OptThen) {
                let then = &then_cfg.value;

                Ok(quote! {
                    parser.entry(#ident)?.on(#value).then(#then);
                })
            } else {
                Ok(quote! {
                    parser.entry(#ident)?.on(#value);
                })
            }
        } else if let Some(cfg) = self.field_cfg.find_cfg(CfgKind::OptFallback) {
            let value = &cfg.value;

            if let Some(fallback) = self.field_cfg.find_cfg(CfgKind::OptThen) {
                let then = &fallback.value;

                Ok(quote! {
                    parser.entry(#ident)?.fallback(#value).then(#then);
                })
            } else {
                Ok(quote! {
                    parser.entry(#ident)?.fallback(#value);
                })
            }
        } else if self.is_sub_command() {
            let policy_ty = self.policy_ty.as_ref().unwrap();
            let unwrap_ty = self.unwrap_ty.as_ref().unwrap();
            let pass_help_to_next = if insert_help {
                quote! {
                    if set.opt(#help_uid)?.val::<bool>().unwrap_or(&false) == &true {
                        // pass a fake flag to next sub command
                        args.push(aopt::RawVal::from(#HELP_OPTION_NAME));
                    }
                }
            } else {
                quote! {}
            };
            let may_be_display_help = if insert_help && abort_help {
                quote! {
                    if parser.find_val::<bool>(#HELP_OPTION_NAME).unwrap_or(&false) == &true {
                        #help_handler
                        std::process::exit(0)
                    }
                }
            } else if abort_help {
                quote! {
                    // ignore abort help here
                }
            } else if insert_help {
                quote! {
                    if parser.find_val::<bool>(#HELP_OPTION_NAME).unwrap_or(&false) == &true {
                        #help_handler
                        std::process::exit(0)
                    }
                }
            } else {
                quote! {}
            };

            Ok(quote! {
                parser.entry(#ident)?.on(
                    move |set: &mut P::Set, ser: &mut P::Ser, args: aopt::prelude::ctx::Args, index: aopt::prelude::ctx::Index| {
                        use std::ops::Deref;

                        let mut args = args.deref().clone().into_inner();
                        let pre_ser_names = ser.sve_val::<Vec<String>>()?;
                        let mut ser_names = pre_ser_names.clone();
                        let current_cmd = args.remove(*index.deref());
                        let current_cmd = current_cmd.get_str();
                        
                        // remove current sub command
                        
                        ser_names.push(current_cmd.ok_or_else(|| 
                            aopt::Error::raise_error(format!("can not convert `{:?}` to str", current_cmd)))?.to_owned()
                        );
                        #pass_help_to_next

                        let args = aopt::ARef::new(aopt::prelude::Args::from_vec(args));
                        let dbg_args = args.clone();
                        let mut parser = <#unwrap_ty as cote::IntoParserDerive<#policy_ty>>::into_parser()?;

                        parser.set_app_data(ser_names.clone())?;
                        parser.init()?;
                        let ret = parser.parse(args).map_err(Into::into);

                        #may_be_display_help
                        match ret?.ok() {
                            Ok(_) => {
                                Ok(<#unwrap_ty>::try_extract(parser.optset_mut()).ok())
                            }
                            Err(e) => {
                                Err(aopt::Error::raise_error(
                                    format!("failed at sub command `{}` with args `{:?}: {:?}",
                                        stringify!(#unwrap_ty), dbg_args, e)))
                            }
                        }
                    }
                );
            })
        } else {
            unreachable!("can not generate handler for field: {:?}", self.ident)
        }
    }

    pub fn has_handler(&self) -> bool {
        self.field_cfg.find_cfg(CfgKind::OptOn).is_some()
            || self.field_cfg.find_cfg(CfgKind::OptFallback).is_some()
            || self.is_sub_command()
    }

    pub fn is_sub_command(&self) -> bool {
        self.is_sub_command
    }

    pub fn generate_command_extract(&self) -> syn::Result<(bool, TokenStream)> {
        let is_ref = self.field_cfg.find_cfg(CfgKind::SubRef).is_some();
        let is_mut = self.field_cfg.find_cfg(CfgKind::SubMut).is_some();
        let ident = self.ident;
        let name = &self.name;

        if is_ref && is_mut {
            abort! {
                ident,
                "can not set both mut and ref on arg"
            }
        } else if is_ref {
            Ok((
                true,
                quote! {
                    #ident: set.find_val(#name).ok(),
                },
            ))
        } else if is_mut {
            Ok((
                false,
                quote! {
                    #ident: set.take_val(#name).ok(),
                },
            ))
        } else if self.is_reference {
            Ok((
                true,
                quote! {
                    #ident:  set.find_val(#name).ok(),
                },
            ))
        } else {
            Ok((
                false,
                quote! {
                    #ident: set.take_val(#name).ok(),
                },
            ))
        }
    }

    pub fn generate_option_extract(&self) -> syn::Result<(bool, TokenStream)> {
        let is_ref = self.field_cfg.find_cfg(CfgKind::OptRef).is_some();
        let is_mut = self.field_cfg.find_cfg(CfgKind::OptMut).is_some();
        let ident = self.ident;
        let name = &self.name;

        if is_ref && is_mut {
            abort! {
                ident,
                "can not set both mut and ref on arg"
            }
        } else if is_ref {
            Ok((
                true,
                quote! {
                    #ident: aopt::prelude::InferValueRef::infer_fetch(#name, set)?,
                },
            ))
        } else if is_mut {
            Ok((
                false,
                quote! {
                    #ident: aopt::prelude::InferValueMut::infer_fetch(#name, set)?,
                },
            ))
        } else if self.is_reference {
            Ok((
                true,
                quote! {
                    #ident: aopt::prelude::InferValueRef::infer_fetch(#name, set)?,
                },
            ))
        } else {
            Ok((
                false,
                quote! {
                    #ident: aopt::prelude::InferValueMut::infer_fetch(#name, set)?,
                },
            ))
        }
    }

    pub fn generate_config(&self) -> syn::Result<TokenStream> {
        if self.is_sub_command() {
            self.generate_command_config()
        } else {
            self.generate_option_config()
        }
    }

    pub fn generate_command_config(&self) -> syn::Result<TokenStream> {
        let config = &self.field_cfg;
        let ident = self.ident;
        let mut ret = quote! {
            let mut config = aopt::prelude::SetCfg::<P::Set>::default();
        };
        let name = &self.name;
        let mut codes = vec![];

        for cfg in config.cfgs.iter() {
            codes.push(match cfg.kind {
                CfgKind::SubPolicy => {
                    quote! {}
                }
                CfgKind::SubAlias => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.add_alias(#token);
                    }
                }
                CfgKind::SubHint => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.set_hint(#token);
                    }
                }
                CfgKind::SubHelp => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.set_help(#token);
                    }
                }
                CfgKind::SubName => {
                    quote! {}
                }
                _ => {
                    abort! {
                        ident, "Unsupport config kind on field macro `sub`: {:?}", cfg.kind
                    }
                }
            });
        }

        codes.push(quote! {
            config.set_name(#name);
        });
        if self.field_cfg.find_cfg(CfgKind::SubHelp).is_none() && !self.comment_doc.is_empty() {
            let mut code = quote! {
                let mut message = String::default();
            };
            for doc in self.comment_doc.iter() {
                code.extend(quote! {
                    message.push_str(#doc);
                });
            }
            codes.push(quote! {
                config.set_help({ #code message });
            })
        }
        codes.push(quote! {
            aopt::opt::Cmd::infer_fill_info(&mut config, true);
            config
        });
        ret.extend(codes.into_iter());
        Ok(ret)
    }

    pub fn generate_option_config(&self) -> syn::Result<TokenStream> {
        let ty = self.ty;
        let ident = self.ident;
        let config = &self.field_cfg;
        let trimed_ty = &self.trimed_ty;
        let mut value = None;

        let mut codes = vec![];
        let name = &self.name;
        let mut ret = quote! {
            let mut config = aopt::prelude::SetCfg::<P::Set>::default();
        };

        for cfg in config.cfgs.iter() {
            codes.push(match cfg.kind {
                CfgKind::OptHint => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.set_hint(#token);
                    }
                }
                CfgKind::OptForce => {
                    quote! {
                        config.set_force(true);
                    }
                }
                CfgKind::OptNoForce => {
                    quote! {
                        config.set_force(false);
                    }
                }
                CfgKind::OptValue => {
                    let token = cfg.value.to_token_stream();

                    value = Some(token.clone());
                    quote! {
                        config.set_initializer(aopt::prelude::ValInitializer::new_value(<<#ty as aopt::prelude::Infer>::Val>::from(#token)));
                    }
                }
                CfgKind::OptValues => {
                    let token = cfg.value.to_token_stream();

                    value = Some(token.clone());
                    quote! {
                        let values = #token.into_iter().map(|v|<<#ty as aopt::prelude::Infer>::Val>::from(v)).collect::<Vec<<#ty as aopt::prelude::Infer>::Val>>();
                        config.set_initializer(aopt::prelude::ValInitializer::new_values(values));
                    }
                }
                CfgKind::OptAlias => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.add_alias(#token);
                    }
                }
                CfgKind::OptAction => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.set_action(#token);
                    }
                }
                CfgKind::OptIndex => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.set_index(aopt::prelude::Index::parse(#token)?);
                    }
                }
                CfgKind::OptValidator => {
                    let token = cfg.value.to_token_stream();

                    quote! {
                        config.set_storer(aopt::prelude::ValStorer::new_validator::<#ty>(#token));
                    }
                }
                CfgKind::OptOn | CfgKind::OptName | CfgKind::OptNoDelay | CfgKind::OptRef | CfgKind::OptMut | CfgKind::OptHelp |
                CfgKind::OptThen | CfgKind::OptFallback => {
                    // will process in another function
                    quote! { }
                }
                _ => {
                    abort! {
                        ident, "Unsupport config kind on field macro `arg`: {:?}", cfg.kind
                    }
                }
            });
        }
        codes.push(quote! {
            config.set_name(#name);
        });

        let mut help_code = None;

        if let Some(help_cfg) = self.field_cfg.find_cfg(CfgKind::OptHelp) {
            let token = &help_cfg.value;

            help_code = Some(quote! {
                let mut message = String::from(#token.trim());
            });
        } else if !self.comment_doc.is_empty() {
            help_code = Some({
                let mut code = quote! {
                    let mut message = String::default();
                };
                let mut iter = self.comment_doc.iter();

                if let Some(doc) = iter.next() {
                    code.extend(quote! {
                        message.push_str(#doc.trim());
                    });
                }
                for doc in iter {
                    code.extend(quote! {
                        message.push_str(" ");
                        message.push_str(#doc.trim());
                    });
                }
                code
            });
        }
        if let Some(mut help_code) = help_code {
            if let Some(value) = value {
                let value_string = value.to_string();

                help_code.extend(quote! {
                    message.push_str(" ");
                    message.push_str("[");
                    message.push_str(#value_string.trim());
                    message.push_str("]");
                });
            }
            codes.push(quote! {
                config.set_help({ #help_code message });
            })
        }
        codes.push(quote! {
            <#trimed_ty>::infer_fill_info(&mut config, true);
            config
        });
        ret.extend(codes.into_iter());
        Ok(ret)
    }
}

pub fn remove_option(ty: &Type) -> syn::Result<Type> {
    if let Type::Path(path) = ty {
        if let Some(segment) = path.path.segments.last() {
            let ident = segment.ident.to_string();

            if ident == "Option" {
                match &segment.arguments {
                    PathArguments::AngleBracketed(ab) => {
                        if let Some(GenericArgument::Type(next_ty)) = ab.args.first().as_ref() {
                            return Ok(next_ty.clone());
                        } else {
                            abort! {
                                ty,
                                "`sub` not support current type"
                            }
                        }
                    }
                    _ => {
                        abort! {
                            ty,
                            "`sub` not support current type"
                        }
                    }
                }
            } else {
                abort! {
                    ty,
                    "`sub` must wrapped with Option"
                }
            }
        }
    }
    Ok(ty.clone())
}

pub fn remove_lifetime(ty: &Type) -> (bool, Type) {
    let mut ty = ty.clone();
    let is_reference;

    if let Type::Reference(reference) = &mut ty {
        is_reference = true;
        remove_reference_lifetime(reference);
    } else {
        is_reference = check_if_reference(&ty);
        if let Type::Path(path) = &mut ty {
            remove_path_lifetime(path);
        }
    }
    (is_reference, ty)
}

pub fn check_if_reference(ty: &Type) -> bool {
    match ty {
        Type::Path(path) => {
            if let Some(segment) = path.path.segments.last() {
                if let PathArguments::AngleBracketed(ab) = &segment.arguments {
                    for arg in ab.args.iter() {
                        if let GenericArgument::Type(next_ty) = arg {
                            return check_if_reference(next_ty);
                        }
                    }
                }
            }
            false
        }
        Type::Reference(_) => true,
        _ => false,
    }
}

pub fn remove_reference_lifetime(ty: &mut TypeReference) {
    ty.lifetime = None;
    match ty.elem.deref_mut() {
        Type::Path(path) => remove_path_lifetime(path),
        Type::Reference(ref_) => remove_reference_lifetime(ref_),
        _ => {
            // do nothing
        }
    }
}

pub fn remove_path_lifetime(ty: &mut TypePath) {
    if let Some(segment) = ty.path.segments.last_mut() {
        if let PathArguments::AngleBracketed(ab) = &mut segment.arguments {
            for arg in ab.args.iter_mut() {
                if let GenericArgument::Type(ty) = arg {
                    match ty {
                        Type::Path(path) => remove_path_lifetime(path),
                        Type::Reference(ref_) => remove_reference_lifetime(ref_),
                        _ => {}
                    };
                } else if let GenericArgument::Lifetime(lifetime) = arg {
                    let span = lifetime.ident.span();
                    lifetime.ident = Ident::new("_", span);
                }
            }
        }
    }
}

pub fn filter_comment_doc(attrs: &[Attribute]) -> Vec<Lit> {
    let attrs = attrs.iter().filter(|v| v.path.is_ident("doc"));
    let mut ret = vec![];

    for attr in attrs {
        if let Ok(syn::Meta::NameValue(meta)) = attr.parse_meta() {
            if let syn::Lit::Str(_) = &meta.lit {
                ret.push(meta.lit);
            }
        }
    }
    ret
}

pub fn check_in_path(ty: &Type, name: &str) -> bool {
    if let Type::Path(path) = ty {
        if let Some(segment) = path.path.segments.last() {
            let ident = segment.ident.to_string();

            if ident == name {
                return true;
            } else if let PathArguments::AngleBracketed(ab) = &segment.arguments {
                for arg in ab.args.iter() {
                    if let GenericArgument::Type(next_ty) = arg {
                        return check_in_path(next_ty, name);
                    }
                }
            }
        }
    } else if let Type::Reference(reference) = ty {
        return check_in_path(reference.elem.as_ref(), name);
    }
    false
}

use crate::prelude::HelpContext;
use crate::Return;

#[derive(Debug, Clone)]
pub struct Frame {
    pub name: String,

    pub failure: Option<Failure>,
}

impl Frame {
    pub fn new(name: String) -> Self {
        Self {
            name,
            failure: None,
        }
    }

    pub fn with_failure(mut self, failure: Failure) -> Self {
        self.failure = Some(failure);
        self
    }

    pub fn set_failure(&mut self, failure: Failure) -> &mut Self {
        self.failure = Some(failure);
        self
    }
}

#[derive(Debug, Clone)]
pub struct Failure {
    pub cmd: String,

    pub retval: Return,
}

impl Failure {
    pub fn new(cmd: String, retval: Return) -> Self {
        Self { cmd, retval }
    }
}

/// Collect running information when do parsing.
#[derive(Debug, Clone, Default)]
pub struct RunningCtx {
    name: String,

    frames: Vec<Frame>,

    sub_level: u8,

    sub_parser: bool,

    exit: bool,

    display_help: bool,

    help_context: Option<HelpContext>,
}

impl RunningCtx {
    // Get api, automate generated by api-gen ...
    pub fn name(&self) -> &str {
        self.name.as_ref()
    }

    pub fn frames(&self) -> &[Frame] {
        &self.frames
    }

    pub fn sub_level(&self) -> u8 {
        self.sub_level
    }

    pub fn sub_parser(&self) -> bool {
        self.sub_parser
    }

    pub fn exit(&self) -> bool {
        self.exit
    }

    pub fn display_help(&self) -> bool {
        self.display_help
    }

    pub fn help_context(&self) -> Option<&HelpContext> {
        self.help_context.as_ref()
    }

    // Mut api, automate generated by api-gen ...
    pub fn frames_mut(&mut self) -> &mut Vec<Frame> {
        &mut self.frames
    }

    pub fn frame_mut(&mut self, index: usize) -> Option<&mut Frame> {
        self.frames.get_mut(index)
    }

    // Set api, automate generated by api-gen ...
    pub fn set_name(&mut self, value: String) -> &mut Self {
        self.name = value;
        self
    }

    pub fn set_frames(&mut self, value: Vec<Frame>) -> &mut Self {
        self.frames = value;
        self
    }

    pub fn set_sub_level(&mut self, value: u8) -> &mut Self {
        self.sub_level = value;
        self
    }

    pub fn set_sub_parser(&mut self, value: bool) -> &mut Self {
        self.sub_parser = value;
        self
    }

    pub fn set_exit(&mut self, value: bool) -> &mut Self {
        self.exit = value;
        self
    }

    pub fn set_display_help(&mut self, value: bool) -> &mut Self {
        self.display_help = value;
        self
    }

    pub fn set_help_context(&mut self, value: HelpContext) -> &mut Self {
        self.help_context = Some(value);
        self
    }

    // With api, automate generated by api-gen ...
    pub fn with_name(mut self, value: String) -> Self {
        self.name = value;
        self
    }

    pub fn with_frames(mut self, value: Vec<Frame>) -> Self {
        self.frames = value;
        self
    }

    pub fn with_sub_level(mut self, value: u8) -> Self {
        self.sub_level = value;
        self
    }

    pub fn with_sub_parser(mut self, value: bool) -> Self {
        self.sub_parser = value;
        self
    }

    pub fn with_exit(mut self, value: bool) -> Self {
        self.exit = value;
        self
    }

    pub fn with_display_help(mut self, value: bool) -> Self {
        self.display_help = value;
        self
    }

    pub fn with_help_context(mut self, value: HelpContext) -> Self {
        self.help_context = Some(value);
        self
    }

    pub fn take_frames(&mut self) -> Vec<Frame> {
        std::mem::take(&mut self.frames)
    }

    pub fn take_help_context(&mut self) -> Option<HelpContext> {
        self.help_context.take()
    }

    pub fn clear_frames(&mut self) {
        self.frames.clear();
    }

    pub fn push_frame(&mut self, frame: Frame) -> &mut Self {
        self.frames.push(frame);
        self
    }

    pub fn pop_frame(&mut self) -> Option<Frame> {
        self.frames.pop()
    }

    pub fn top_frame(&mut self) -> Option<&mut Frame> {
        self.frames.last_mut()
    }

    pub fn reset_at(&self, level: u8) -> Self {
        Self {
            name: self.name.clone(),
            frames: self.frames[..level as usize].to_vec(),
            sub_level: level,
            sub_parser: false,
            exit: false,
            display_help: false,
            help_context: None,
        }
    }

    pub fn inc_sub_level(&mut self) -> &mut Self {
        self.sub_level += 1;
        self
    }

    pub fn dec_sub_level(&mut self) -> &mut Self {
        self.sub_level -= 1;
        self
    }

    pub fn chain_error(&mut self) -> Option<aopt::Error> {
        let mut iter = self.frames.iter_mut();

        if let Some(frame) = iter.next() {
            let mut error = frame.failure.take()?.retval.take_failure()?;

            for frame in iter {
                error = error.cause(frame.failure.take()?.retval.take_failure()?);
            }
            Some(error)
        } else {
            None
        }
    }
}

#[doc(hidden)]
#[derive(Debug, Clone, Copy, Default)]
pub struct HideValue<T>(pub T);
